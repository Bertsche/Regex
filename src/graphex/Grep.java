

package graphex;

import java.io.*;
import java.util.HashSet;

/**
 * This is the main class for the a regex program that builds an NFA and DFA for a given regular expression,
 * and outputs the complete line that matches the given regex.  The scan is done by traversing the dfa.  It accepts
 * optional '-n' and '-d' parameters for outputting dot files of the dfa and nfa files for your viewing pleasure
 * @author Ryan Bertsche
 *
 */
public class Grep
{
    //This is a set of characters for the language in the input
    private static HashSet<Character> language = new HashSet<>();
    //boolean that is set when reading arguments to tell the program if it should output nfa and/or dfa dot files
    private static boolean printNFA;
    private static boolean printDFA;
    //Strings that hold the nfa and dfa dot output file names respectively, that the dot file will be written to
    private static String dfaOutput;
    private static String nfaOutput;
    //Holds the inputted regex string before it gets parsed
    private static String regexAsString;
    //Holds the file name of the input file that will be scanned over to be matched
    private static String inputFileName;
    //Holds the nfa and dfa tree that is returned from the parser method
    private static FiniteAutomataTree dfa;
    private static FiniteAutomataTree nfa;
    //This is the parser object that turns the regex string into dfa nad nfa
    private static Parser inputParse;


    /**
     * Main method that accepts the arguments in the format  [-n NFA-FILE] [-d DFA-FILE] REGEX FILE.  As a result, the
     * lines that match the regex will be outputted.  This method first parses the arguments to find out which optional
     * inputs are chosen, and assigns all arguments to the appropriate variables above,and sets the print flags accordingly
     * @param args is the list of string arguments passed when calling the program
     */
    public static void main(String args[])
    {


        String option1 = args[0].substring(0, 2);
        String option2 = args[1].substring(0,2);


        //Analyze the arguments and pull all the data based on the options
        if(option1.equals("-n"))
        {
            printNFA = true;
            nfaOutput = (args[0].substring(2)).trim();
            if(option2.equals("-d"))
            {
                printDFA = true;
                dfaOutput = (args[1].substring(2)).trim();
                regexAsString = args[2];
                inputFileName = args[3];
            }
            else {
                printDFA = false;
                dfaOutput = "";
                regexAsString = args[1];
                inputFileName = args[2];
            }
        }
        else if(option1.equals("-d"))
        {
            printNFA = false;
            printDFA = true;
            nfaOutput = "";
            dfaOutput = (args[0].substring(2)).trim();
            regexAsString = args[1];
            inputFileName = args[2];
        }
        else{
            printDFA = false;
            printNFA = false;
            nfaOutput = "";
            dfaOutput = "";
            regexAsString = args[0];
            inputFileName = args[1];
        }
        //Now that the inputs are determined, the language can be set
        setLanguage();

        //instantiates the Parser method with the argument of the string regex
        inputParse = new Parser(regexAsString);

        //retrieves the nfa and dfa respectively that have been generated by the parser
        nfa = inputParse.getNfaTree();
        dfa = inputParse.getDfaTree();

        //Call to the method that runs regex matching over the input file via the dfa
        run();

        //Checks the print dot file flags and calls the to dot method and file writer methods accordingly
        if(printDFA)
            writeToFile(dfaOutput, toDot(dfa));
        if(printNFA)
            writeToFile(nfaOutput, toDot(nfa));






    }

    /**
     * This is a getter method for the language of characters used in the input file
     * @return the language of characters for the program
     */
    public static HashSet<Character> getLanguage()
    {
        return language;
    }

    /**
     * This is an internal helper-setter method that parses the input file and makes a set of all characters found in
     * the input,which is the language of the dfa/nfa
     */
    public static void setLanguage()
    {

        FileInputStream fileInput = null;
        try {
            fileInput = new FileInputStream(inputFileName);
            int r;
            //Reads file until all characters are read
            while ((r = fileInput.read()) != -1)
            {
                //Check to make sure none of reserved, unescapable characters used fot the regex are in the file,as per the assignment.They cannot be added to the language
                if(!(r == 40 || r == 41 || r == 42 || r == 124 || r == 10 ))
                {
                    char c = (char) r;
                    language.add(c);
                }
                //If any reserved characters are in the file, an error is thrown
                else if((r == 40 || r == 41 || r == 42 || r == 124 ))
                    throw new Error("FATAL ERROR, OPERATION ABORTED: The input file cannot contain the characters '(, ')' , '*' , or '|'.");



            }
            fileInput.close();

        }
        catch (java.io.IOException e) {
            e.printStackTrace();
            System.out.println("There was an error trying to read the file input file");
        }

    }

    /**
     * This is the helper method that handles the actual matching of the input to the dfa, based on the inputted regex
     */
    private static void run()
    {

        FileInputStream fileInput2 = null;
        BufferedReader buff = null;
        InputStreamReader sr = null;
        try {
            fileInput2 = new FileInputStream(inputFileName);
            sr = new InputStreamReader(fileInput2);
            buff =  new BufferedReader(sr);
            String line =  null;
            System.out.println("The following lines from the input file match the regex: ");

            //gets the text from the file line by line, and does so until there are no more lines in the file.Line seperators are not included in the string
            while ((line = buff.readLine()) != null)
            {
                /*There is a check to make sure there is no non-ascii character in the line trying to be matched, because
                *the language cannot hold non-ascii characters, and trying to match one would cause a null pointer exception,
                * plus they are not allowed in the scope of this project.
                */
                boolean invalidChar = false;
                for(char c: line.toCharArray())
                {
                    int asciiVal = (int)c;
                    if (asciiVal < 0 || asciiVal > 255)
                        invalidChar = true;
                }

                //As long as the line contains no invalid characters, the matcher method is called, which does the actual matching with the dfa
                if(! invalidChar) {
                    if (match(line)) {
                        //If a line does match, it is printed to the output
                        System.out.println(line);
                    }
                }



            }
            fileInput2.close();
        }
        catch (java.io.IOException e) {
            e.printStackTrace();
            System.out.println("There was an error trying to read the file input file");
        }
    }

    /**
     * This method traverses the dfa by reading a line from the input character by character, starting at the start node.
     * After all the inputs are read,the current state is checked to see if it is an accpet state.  If it is an accpet,
     * true is returned.  If it is not, false is returned
     * @param line is a String of a single line form the file to be checked for a regex match
     * @return boolean true if matches regex, false otherwise
     */
    private static boolean match(String line)
    {
        //Node holder that is set to the start node of the dfa
        FiniteAutomataNode current;
        current = dfa.getStartNode();

        //goes through every single character in the line
        for(Character c: line.toCharArray())
        {

                //sets  the current node to the node mapped to that transition
                current = current.getMappedValue(c);



        }
            //after all characters are done, returns if the current node is an accept node
            return current.getAccept();

    }

    /**
     * This is a method used for testing purposes to make sure all nodes transition to all character, but it is
     * not used during standard execution of this program
     */
    private static void testAllPrinter()
    {
        for(FiniteAutomataNode fan : dfa.getAllNodes())
        {
            System.out.println("Node : " + fan.getName() + ":");
            System.out.println("The characters that transition out of this node are as follows: ");
            for (Character c: fan.getKeys())
            {
                System.out.print(c + ", ");
            }

            System.out.print("\n Start State: " + (fan.getName().equals(dfa.getStartNode().getName())) + "\n");


        }
    }

    /**
     * This method takes in a finite automata tree, (either the nfa or dfa), and parses through it to build a string in
     * dot file format.  All characters that transition between 2 nodes are placed on the same transition line, for the
     * sake of clarity and readability.  With each transition per character beiong its own lines, it is so cluttered with
     * overlapping lines and characters, it is nearly impossible to read.
     * @param tree to be parsed and turned into a dot string
     * @return String text of dot file that will be written to file
     */
    private static String toDot(FiniteAutomataTree tree)
    {
        //Header for dot file
        String fullString = "digraph finite_automata{\nrankdir=LR;\nvirtualStart [style = invisible ];\n";
        //Three separate string that will hold different pieces of the final file
        String subAccept = "";
        String subNotAccept = "";
        String subTransitions = "";
        //Pieces of dot file that will list which states are accept and should be double circle, and which will be single circle
        subAccept += "node [shape = doublecircle]; ";
        subNotAccept += "node [shape = circle]; ";

        //Loop that traverses all the nodes within a tree
        for(FiniteAutomataNode fan : tree.getAllNodes())
        {
            //gets name of node that will be used to label nodes
            String name = fan.getName();

            //Adds all the accept and non accept nodes to the line that signifies single or double circle in output
            if (fan.getAccept())
                subAccept += "\"" + name + "\" ";
            else
                subNotAccept += "\"" + name + "\" ";

            //Loop for every node the current node can transition to.  This is the loop that makes all the trans
            for(FiniteAutomataNode destinationNode: new HashSet<>(fan.getValues()))
            {
                String transChars = "";
                //Loops through all characters that the current node transitions on(For DFA this is all chars in language).
                // This makes a string listing all characters that transition between two particular nodes
                for(Character c: fan.getKeys())
                {
                    //Gets all character transitions betweenn two nodes
                    if(fan.getMappedValue(c).equals(destinationNode))
                        transChars += "'" + c + "', ";
                }
                //Adds the transition between two nodes to the dot file
                subTransitions += "\"" + name + "\" -> \""  + destinationNode.getName() + "\" [ label = \"" + transChars + "\" ];\n";
            }

            //This adds all the epsilon transition by scanning the epsilon transition list
            for(FiniteAutomataNode epsilons : fan.getEpsilonTransitions())
            {
                subTransitions += "\"" + name + "\" -> \""  + epsilons.getName() + "\" [ label = \"ε\" ];\n";
            }


        }
        subAccept += ";\n";
        subNotAccept += ";\n";

        //puts all the pieces together to make the full string to be returned
        fullString += subAccept + subNotAccept + subTransitions + "virtualStart -> \"" + tree.getStartNode().getName() + "\"\n}";
        return fullString;

    }


    /**
     * Writes the dot strings out to the destination
     * @param destination is the name of the file to be written to
     * @param toBeWritten is the string of the dot file that will written to the file
     */
    private static void writeToFile(String destination, String toBeWritten)
    {
        System.out.println("writing to destination: " + destination);
        try {
            FileWriter writer = new FileWriter(destination);
            writer.write(toBeWritten);
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }





}
